{"ast":null,"code":"import _asyncToGenerator from \"/Users/jaymardaligdig/Desktop/poskimay/offline-version/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./sqlite.service\";\nexport let DatabaseService = /*#__PURE__*/(() => {\n  class DatabaseService {\n    constructor(sqlite) {\n      this.sqlite = sqlite;\n    }\n    /**\n     * this function will handle the sqlite isopen and isclosed automatically for you.\n     * @param callback: The callback function that will execute multiple SQLiteDBConnection commands or other stuff.\n     * @param databaseName optional another database name\n     * @returns any type you want to receive from the callback function.\n     */\n\n\n    executeQuery(callback, databaseName = environment.databaseName) {\n      var _this = this;\n\n      return _asyncToGenerator(function* () {\n        try {\n          let isConnection = yield _this.sqlite.isConnection(databaseName);\n\n          if (isConnection.result) {\n            let db = yield _this.sqlite.retrieveConnection(databaseName);\n            return yield callback(db);\n          } else {\n            const db = yield _this.sqlite.createConnection(databaseName, false, \"no-encryption\", 1);\n            yield db.open();\n            let cb = yield callback(db);\n            yield _this.sqlite.closeConnection(databaseName);\n            return cb;\n          }\n        } catch (error) {\n          throw Error(`DatabaseServiceError: ${error}`);\n        }\n      })();\n    }\n\n  }\n\n  DatabaseService.ɵfac = function DatabaseService_Factory(t) {\n    return new (t || DatabaseService)(i0.ɵɵinject(i1.SQLiteService));\n  };\n\n  DatabaseService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: DatabaseService,\n    factory: DatabaseService.ɵfac\n  });\n  return DatabaseService;\n})();","map":{"version":3,"sources":["/Users/jaymardaligdig/Desktop/poskimay/offline-version/src/app/services/database.service.ts"],"names":["environment","i0","i1","DatabaseService","constructor","sqlite","executeQuery","callback","databaseName","isConnection","result","db","retrieveConnection","createConnection","open","cb","closeConnection","error","Error","ɵfac","DatabaseService_Factory","t","ɵɵinject","SQLiteService","ɵprov","ɵɵdefineInjectable","token","factory"],"mappings":";AAAA,SAASA,WAAT,QAA4B,8BAA5B;AACA,OAAO,KAAKC,EAAZ,MAAoB,eAApB;AACA,OAAO,KAAKC,EAAZ,MAAoB,kBAApB;AACA,WAAaC,eAAb;AAAO,QAAMA,eAAN,CAAsB;AACzBC,IAAAA,WAAW,CAACC,MAAD,EAAS;AAChB,WAAKA,MAAL,GAAcA,MAAd;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACUC,IAAAA,YAAY,CAACC,QAAD,EAAWC,YAAY,GAAGR,WAAW,CAACQ,YAAtC,EAAoD;AAAA;;AAAA;AAClE,YAAI;AACA,cAAIC,YAAY,SAAS,KAAI,CAACJ,MAAL,CAAYI,YAAZ,CAAyBD,YAAzB,CAAzB;;AACA,cAAIC,YAAY,CAACC,MAAjB,EAAyB;AACrB,gBAAIC,EAAE,SAAS,KAAI,CAACN,MAAL,CAAYO,kBAAZ,CAA+BJ,YAA/B,CAAf;AACA,yBAAaD,QAAQ,CAACI,EAAD,CAArB;AACH,WAHD,MAIK;AACD,kBAAMA,EAAE,SAAS,KAAI,CAACN,MAAL,CAAYQ,gBAAZ,CAA6BL,YAA7B,EAA2C,KAA3C,EAAkD,eAAlD,EAAmE,CAAnE,CAAjB;AACA,kBAAMG,EAAE,CAACG,IAAH,EAAN;AACA,gBAAIC,EAAE,SAASR,QAAQ,CAACI,EAAD,CAAvB;AACA,kBAAM,KAAI,CAACN,MAAL,CAAYW,eAAZ,CAA4BR,YAA5B,CAAN;AACA,mBAAOO,EAAP;AACH;AACJ,SAbD,CAcA,OAAOE,KAAP,EAAc;AACV,gBAAMC,KAAK,CAAE,yBAAwBD,KAAM,EAAhC,CAAX;AACH;AAjBiE;AAkBrE;;AA5BwB;;AA8B7Bd,EAAAA,eAAe,CAACgB,IAAhB,GAAuB,SAASC,uBAAT,CAAiCC,CAAjC,EAAoC;AAAE,WAAO,KAAKA,CAAC,IAAIlB,eAAV,EAA2BF,EAAE,CAACqB,QAAH,CAAYpB,EAAE,CAACqB,aAAf,CAA3B,CAAP;AAAmE,GAAhI;;AACApB,EAAAA,eAAe,CAACqB,KAAhB,GAAwB,aAAcvB,EAAE,CAACwB,kBAAH,CAAsB;AAAEC,IAAAA,KAAK,EAAEvB,eAAT;AAA0BwB,IAAAA,OAAO,EAAExB,eAAe,CAACgB;AAAnD,GAAtB,CAAtC;AA/BA,SAAahB,eAAb;AAAA","sourcesContent":["import { environment } from 'src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./sqlite.service\";\nexport class DatabaseService {\n    constructor(sqlite) {\n        this.sqlite = sqlite;\n    }\n    /**\n     * this function will handle the sqlite isopen and isclosed automatically for you.\n     * @param callback: The callback function that will execute multiple SQLiteDBConnection commands or other stuff.\n     * @param databaseName optional another database name\n     * @returns any type you want to receive from the callback function.\n     */\n    async executeQuery(callback, databaseName = environment.databaseName) {\n        try {\n            let isConnection = await this.sqlite.isConnection(databaseName);\n            if (isConnection.result) {\n                let db = await this.sqlite.retrieveConnection(databaseName);\n                return await callback(db);\n            }\n            else {\n                const db = await this.sqlite.createConnection(databaseName, false, \"no-encryption\", 1);\n                await db.open();\n                let cb = await callback(db);\n                await this.sqlite.closeConnection(databaseName);\n                return cb;\n            }\n        }\n        catch (error) {\n            throw Error(`DatabaseServiceError: ${error}`);\n        }\n    }\n}\nDatabaseService.ɵfac = function DatabaseService_Factory(t) { return new (t || DatabaseService)(i0.ɵɵinject(i1.SQLiteService)); };\nDatabaseService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: DatabaseService, factory: DatabaseService.ɵfac });\n"]},"metadata":{},"sourceType":"module"}